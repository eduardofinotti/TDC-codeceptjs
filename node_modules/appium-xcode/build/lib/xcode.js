"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVersion = getVersion;
exports.getAutomationTraceTemplatePathWithoutRetry = getAutomationTraceTemplatePathWithoutRetry;
exports.getMaxIOSSDKWithoutRetry = getMaxIOSSDKWithoutRetry;
exports.getConnectedDevices = getConnectedDevices;
exports.clearInternalCache = clearInternalCache;
exports.getCommandLineToolsVersion = getCommandLineToolsVersion;
exports.getMaxTVOSSDKWithoutRetry = getMaxTVOSSDKWithoutRetry;
exports.getMaxTVOSSDK = exports.getInstrumentsPath = exports.getMaxIOSSDK = exports.getAutomationTraceTemplatePath = exports.getPath = void 0;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _asyncbox = require("asyncbox");

var _lodash = _interopRequireDefault(require("lodash"));

var _plist = require("plist");

var _teen_process = require("teen_process");

var _semver = _interopRequireDefault(require("semver"));

const env = process.env;
const XCRUN_TIMEOUT = 15000;
const XCODE_SUBDIR = "/Contents/Developer";
const DEFAULT_NUMBER_OF_RETRIES = 3;

const log = _appiumSupport.logger.getLogger('Xcode');

function hasExpectedSubDir(path) {
  return path.substring(path.length - XCODE_SUBDIR.length) === XCODE_SUBDIR;
}

function runXcrunCommand(_x) {
  return _runXcrunCommand.apply(this, arguments);
}

function _runXcrunCommand() {
  _runXcrunCommand = (0, _asyncToGenerator2.default)(function* (args, timeout = XCRUN_TIMEOUT) {
    try {
      return yield (0, _teen_process.exec)('xcrun', args, {
        timeout
      });
    } catch (err) {
      if (err.stderr) {
        err.message = `${err.message}: ${err.stderr}`;
      }

      throw err;
    }
  });
  return _runXcrunCommand.apply(this, arguments);
}

function getPathFromSymlink(_x2) {
  return _getPathFromSymlink.apply(this, arguments);
}

function _getPathFromSymlink() {
  _getPathFromSymlink = (0, _asyncToGenerator2.default)(function* (failMessage) {
    log.warn(`Finding XcodePath by symlink because ${failMessage}`);
    const symlinkPath = "/var/db/xcode_select_link";
    const legacySymlinkPath = "/usr/share/xcode-select/xcode_dir_link";
    let xcodePath = null;

    if (_appiumSupport.util.hasContent(env.DEVELOPER_DIR)) {
      const customPath = hasExpectedSubDir(env.DEVELOPER_DIR) ? env.DEVELOPER_DIR : env.DEVELOPER_DIR + XCODE_SUBDIR;

      if (yield _appiumSupport.fs.exists(customPath)) {
        xcodePath = customPath;
      } else {
        let mesg = `Could not find path to Xcode, environment variable ` + `DEVELOPER_DIR set to: ${env.DEVELOPER_DIR} ` + `but no Xcode found`;
        log.warn(mesg);
        throw new Error(mesg);
      }
    } else if (yield _appiumSupport.fs.exists(symlinkPath)) {
      xcodePath = yield _appiumSupport.fs.readlink(symlinkPath);
    } else if (yield _appiumSupport.fs.exists(legacySymlinkPath)) {
      xcodePath = yield _appiumSupport.fs.readlink(legacySymlinkPath);
    }

    if (xcodePath) {
      return xcodePath.replace(new RegExp("/$"), "").trim();
    }

    let msg = `Could not find path to Xcode by symlinks located in ${symlinkPath}, or ${legacySymlinkPath}`;
    log.warn(msg);
    throw new Error(msg);
  });
  return _getPathFromSymlink.apply(this, arguments);
}

function getPathFromXcodeSelect() {
  return _getPathFromXcodeSelect.apply(this, arguments);
}

function _getPathFromXcodeSelect() {
  _getPathFromXcodeSelect = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    let _ref = yield (0, _teen_process.exec)('xcode-select', ['--print-path'], {
      timeout
    }),
        stdout = _ref.stdout;

    const xcodeFolderPath = stdout.replace(/\/$/, '').trim();

    if (!_appiumSupport.util.hasContent(xcodeFolderPath)) {
      log.errorAndThrow('xcode-select returned an empty string');
    }

    if (yield _appiumSupport.fs.exists(xcodeFolderPath)) {
      return xcodeFolderPath;
    } else {
      const msg = `xcode-select could not find xcode. Path '${xcodeFolderPath}' does not exist.`;
      log.errorAndThrow(msg);
    }
  });
  return _getPathFromXcodeSelect.apply(this, arguments);
}

const getPath = _lodash.default.memoize(function (timeout = XCRUN_TIMEOUT) {
  return getPathFromXcodeSelect(timeout).catch(getPathFromSymlink);
});

exports.getPath = getPath;

function getVersionWithoutRetry() {
  return _getVersionWithoutRetry.apply(this, arguments);
}

function _getVersionWithoutRetry() {
  _getVersionWithoutRetry = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const xcodePath = yield getPath(timeout);

    const plistPath = _path.default.resolve(xcodePath, "..", "Info.plist");

    if (!(yield _appiumSupport.fs.exists(plistPath))) {
      throw new Error(`Could not get Xcode version. ${plistPath} does not exist on disk.`);
    }

    const version = yield _appiumSupport.plist.parsePlistFile(plistPath);
    return _semver.default.coerce(version.CFBundleShortVersionString);
  });
  return _getVersionWithoutRetry.apply(this, arguments);
}

const getVersionMemoized = _lodash.default.memoize(function (retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getVersionWithoutRetry, timeout);
});

function getVersion() {
  return _getVersion.apply(this, arguments);
}

function _getVersion() {
  _getVersion = (0, _asyncToGenerator2.default)(function* (parse = false, retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
    const version = yield getVersionMemoized(retries, timeout);
    const versionString = version.patch > 0 ? version.version : `${version.major}.${version.minor}`;

    if (!parse) {
      return versionString;
    }

    return {
      versionString,
      versionFloat: parseFloat(versionString),
      major: version.major,
      minor: version.minor,
      patch: version.patch > 0 ? version.patch : undefined
    };
  });
  return _getVersion.apply(this, arguments);
}

function getCommandLineToolsVersion() {
  return _getCommandLineToolsVersion.apply(this, arguments);
}

function _getCommandLineToolsVersion() {
  _getCommandLineToolsVersion = (0, _asyncToGenerator2.default)(function* () {
    const getVersionFunctions = [(0, _asyncToGenerator2.default)(function* () {
      let pkg = (yield (0, _teen_process.exec)('pkgutil', ['--pkgs=com.apple.pkg.DevSDK_.*'])).stdout;
      return (yield (0, _teen_process.exec)('pkgutil', [`--pkg-info=${pkg.trim()}`])).stdout;
    }), (0, _asyncToGenerator2.default)(function* () {
      return (yield (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.CLTools_Executables`])).stdout;
    }), (0, _asyncToGenerator2.default)(function* () {
      return (yield (0, _teen_process.exec)('pkgutil', [`--pkg-info=com.apple.pkg.DeveloperToolsCLI`])).stdout;
    })];
    let stdout;

    for (var _i = 0; _i < getVersionFunctions.length; _i++) {
      let getVersion = getVersionFunctions[_i];

      try {
        stdout = yield getVersion();
        break;
      } catch (ign) {
        stdout = '';
      }
    }

    let match = /^version: (.+)$/m.exec(stdout);
    return match ? match[1] : undefined;
  });
  return _getCommandLineToolsVersion.apply(this, arguments);
}

function getAutomationTraceTemplatePathWithoutRetry() {
  return _getAutomationTraceTemplatePathWithoutRetry.apply(this, arguments);
}

function _getAutomationTraceTemplatePathWithoutRetry() {
  _getAutomationTraceTemplatePathWithoutRetry = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const xcodePath = yield getPath(timeout);
    const extensions = ['xrplugin', 'bundle'];

    const pathPrefix = _path.default.resolve(xcodePath, "../Applications/Instruments.app/Contents/PlugIns");

    const pathSuffix = "Contents/Resources/Automation.tracetemplate";
    let automationTraceTemplatePaths = [_path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[0]}`, pathSuffix), _path.default.resolve(pathPrefix, `AutomationInstrument.${extensions[1]}`, pathSuffix)];

    if (yield _appiumSupport.fs.exists(automationTraceTemplatePaths[0])) {
      return automationTraceTemplatePaths[0];
    }

    if (yield _appiumSupport.fs.exists(automationTraceTemplatePaths[1])) {
      return automationTraceTemplatePaths[1];
    }

    const msg = "Could not find Automation.tracetemplate in any of the following" + `locations ${automationTraceTemplatePaths.toString()}`;
    log.error(msg);
    throw new Error(msg);
  });
  return _getAutomationTraceTemplatePathWithoutRetry.apply(this, arguments);
}

const getAutomationTraceTemplatePath = _lodash.default.memoize(function (retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getAutomationTraceTemplatePathWithoutRetry, timeout);
});

exports.getAutomationTraceTemplatePath = getAutomationTraceTemplatePath;

function getMaxIOSSDKWithoutRetry() {
  return _getMaxIOSSDKWithoutRetry.apply(this, arguments);
}

function _getMaxIOSSDKWithoutRetry() {
  _getMaxIOSSDKWithoutRetry = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const version = yield getVersion(false, DEFAULT_NUMBER_OF_RETRIES, timeout);

    if (version[0] === '4') {
      return '6.1';
    }

    const args = ['--sdk', 'iphonesimulator', '--show-sdk-version'];

    const _ref5 = yield runXcrunCommand(args, timeout),
          stdout = _ref5.stdout;

    const sdkVersion = stdout.trim();
    const match = /\d.\d/.exec(stdout);

    if (!match) {
      throw new Error(`xcrun returned a non-numeric iOS SDK version: '${sdkVersion}'`);
    }

    return sdkVersion;
  });
  return _getMaxIOSSDKWithoutRetry.apply(this, arguments);
}

const getMaxIOSSDK = _lodash.default.memoize(function (retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxIOSSDKWithoutRetry, timeout);
});

exports.getMaxIOSSDK = getMaxIOSSDK;

function getMaxTVOSSDKWithoutRetry() {
  return _getMaxTVOSSDKWithoutRetry.apply(this, arguments);
}

function _getMaxTVOSSDKWithoutRetry() {
  _getMaxTVOSSDKWithoutRetry = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const args = ['--sdk', 'appletvsimulator', '--show-sdk-version'];

    const _ref6 = yield runXcrunCommand(args, timeout),
          stdout = _ref6.stdout;

    const sdkVersion = stdout.trim();

    if (isNaN(parseFloat(sdkVersion))) {
      throw new Error(`xcrun returned a non-numeric tvOS SDK version: '${sdkVersion}'`);
    }

    return sdkVersion;
  });
  return _getMaxTVOSSDKWithoutRetry.apply(this, arguments);
}

const getMaxTVOSSDK = _lodash.default.memoize(function (retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getMaxTVOSSDKWithoutRetry, timeout);
});

exports.getMaxTVOSSDK = getMaxTVOSSDK;

function getConnectedDevices() {
  return _getConnectedDevices.apply(this, arguments);
}

function _getConnectedDevices() {
  _getConnectedDevices = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const cmd = '/usr/sbin/system_profiler';
    const args = ['-xml', 'SPUSBDataType'];

    let _ref7 = yield (0, _teen_process.exec)(cmd, args, {
      timeout
    }),
        stdout = _ref7.stdout;

    let plistContent = (0, _plist.parse)(stdout);
    let devicesFound = [];
    let entriesToSearch = [plistContent[0]];

    while (entriesToSearch.length > 0) {
      let currentEntry = entriesToSearch.pop();

      if (currentEntry instanceof Array) {
        entriesToSearch = entriesToSearch.concat(currentEntry);
      } else if (currentEntry._name && currentEntry._name.substring(0, 4) === "iPad" || currentEntry._name && currentEntry._name.substring(0, 6) === "iPhone" || currentEntry._name && _lodash.default.includes(currentEntry._name, "Apple TV")) {
        let deviceInfo = {
          name: currentEntry._name,
          udid: currentEntry.serial_num,
          productId: currentEntry.product_id,
          deviceVersion: currentEntry.bcd_device
        };
        devicesFound.push(deviceInfo);
      } else if (currentEntry._items) {
        entriesToSearch = entriesToSearch.concat(currentEntry._items);
      }
    }

    return devicesFound;
  });
  return _getConnectedDevices.apply(this, arguments);
}

function getInstrumentsPathWithoutRetry() {
  return _getInstrumentsPathWithoutRetry.apply(this, arguments);
}

function _getInstrumentsPathWithoutRetry() {
  _getInstrumentsPathWithoutRetry = (0, _asyncToGenerator2.default)(function* (timeout = XCRUN_TIMEOUT) {
    const args = ['-find', 'instruments'];

    let _ref8 = yield runXcrunCommand(args, timeout),
        stdout = _ref8.stdout;

    if (!stdout) {
      stdout = "";
    }

    let instrumentsPath = stdout.trim();

    if (!instrumentsPath) {
      throw new Error(`Could not find path to instruments binary using 'xcrun ${args.join(' ')}'`);
    }

    return instrumentsPath;
  });
  return _getInstrumentsPathWithoutRetry.apply(this, arguments);
}

const getInstrumentsPath = _lodash.default.memoize(function (retries = DEFAULT_NUMBER_OF_RETRIES, timeout = XCRUN_TIMEOUT) {
  return (0, _asyncbox.retry)(retries, getInstrumentsPathWithoutRetry, timeout);
});

exports.getInstrumentsPath = getInstrumentsPath;

function clearInternalCache() {
  const memoized = [getPath, getVersionMemoized, getAutomationTraceTemplatePath, getMaxIOSSDK, getMaxTVOSSDK, getInstrumentsPath];
  memoized.forEach(f => {
    if (f.cache) {
      f.cache = new _lodash.default.memoize.Cache();
    }
  });
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi94Y29kZS5qcyJdLCJuYW1lcyI6WyJlbnYiLCJwcm9jZXNzIiwiWENSVU5fVElNRU9VVCIsIlhDT0RFX1NVQkRJUiIsIkRFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMiLCJsb2ciLCJsb2dnZXIiLCJnZXRMb2dnZXIiLCJoYXNFeHBlY3RlZFN1YkRpciIsInBhdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJydW5YY3J1bkNvbW1hbmQiLCJhcmdzIiwidGltZW91dCIsImVyciIsInN0ZGVyciIsIm1lc3NhZ2UiLCJnZXRQYXRoRnJvbVN5bWxpbmsiLCJmYWlsTWVzc2FnZSIsIndhcm4iLCJzeW1saW5rUGF0aCIsImxlZ2FjeVN5bWxpbmtQYXRoIiwieGNvZGVQYXRoIiwidXRpbCIsImhhc0NvbnRlbnQiLCJERVZFTE9QRVJfRElSIiwiY3VzdG9tUGF0aCIsImZzIiwiZXhpc3RzIiwibWVzZyIsIkVycm9yIiwicmVhZGxpbmsiLCJyZXBsYWNlIiwiUmVnRXhwIiwidHJpbSIsIm1zZyIsImdldFBhdGhGcm9tWGNvZGVTZWxlY3QiLCJzdGRvdXQiLCJ4Y29kZUZvbGRlclBhdGgiLCJlcnJvckFuZFRocm93IiwiZ2V0UGF0aCIsIl8iLCJtZW1vaXplIiwiY2F0Y2giLCJnZXRWZXJzaW9uV2l0aG91dFJldHJ5IiwicGxpc3RQYXRoIiwicmVzb2x2ZSIsInZlcnNpb24iLCJwbGlzdCIsInBhcnNlUGxpc3RGaWxlIiwic2VtdmVyIiwiY29lcmNlIiwiQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmciLCJnZXRWZXJzaW9uTWVtb2l6ZWQiLCJyZXRyaWVzIiwiZ2V0VmVyc2lvbiIsInBhcnNlIiwidmVyc2lvblN0cmluZyIsInBhdGNoIiwibWFqb3IiLCJtaW5vciIsInZlcnNpb25GbG9hdCIsInBhcnNlRmxvYXQiLCJ1bmRlZmluZWQiLCJnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiIsImdldFZlcnNpb25GdW5jdGlvbnMiLCJwa2ciLCJpZ24iLCJtYXRjaCIsImV4ZWMiLCJnZXRBdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhXaXRob3V0UmV0cnkiLCJleHRlbnNpb25zIiwicGF0aFByZWZpeCIsInBhdGhTdWZmaXgiLCJhdXRvbWF0aW9uVHJhY2VUZW1wbGF0ZVBhdGhzIiwidG9TdHJpbmciLCJlcnJvciIsImdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCIsImdldE1heElPU1NES1dpdGhvdXRSZXRyeSIsInNka1ZlcnNpb24iLCJnZXRNYXhJT1NTREsiLCJnZXRNYXhUVk9TU0RLV2l0aG91dFJldHJ5IiwiaXNOYU4iLCJnZXRNYXhUVk9TU0RLIiwiZ2V0Q29ubmVjdGVkRGV2aWNlcyIsImNtZCIsInBsaXN0Q29udGVudCIsImRldmljZXNGb3VuZCIsImVudHJpZXNUb1NlYXJjaCIsImN1cnJlbnRFbnRyeSIsInBvcCIsIkFycmF5IiwiY29uY2F0IiwiX25hbWUiLCJpbmNsdWRlcyIsImRldmljZUluZm8iLCJuYW1lIiwidWRpZCIsInNlcmlhbF9udW0iLCJwcm9kdWN0SWQiLCJwcm9kdWN0X2lkIiwiZGV2aWNlVmVyc2lvbiIsImJjZF9kZXZpY2UiLCJwdXNoIiwiX2l0ZW1zIiwiZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5IiwiaW5zdHJ1bWVudHNQYXRoIiwiam9pbiIsImdldEluc3RydW1lbnRzUGF0aCIsImNsZWFySW50ZXJuYWxDYWNoZSIsIm1lbW9pemVkIiwiZm9yRWFjaCIsImYiLCJjYWNoZSIsIkNhY2hlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQSxNQUFNQSxHQUFHLEdBQUdDLE9BQU8sQ0FBQ0QsR0FBcEI7QUFFQSxNQUFNRSxhQUFhLEdBQUcsS0FBdEI7QUFDQSxNQUFNQyxZQUFZLEdBQUcscUJBQXJCO0FBQ0EsTUFBTUMseUJBQXlCLEdBQUcsQ0FBbEM7O0FBRUEsTUFBTUMsR0FBRyxHQUFHQyxzQkFBT0MsU0FBUCxDQUFp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QUFGLENBQ3pCLFVBQVVZLE9BQU8sR0FBR25ELHlCQUFwQixFQUErQ1UsT0FBTyxHQUFHWixhQUF6RCxFQUF3RTtBQUN0RSxTQUFPLHFCQUFNcUQsT0FBTixFQUFlbUQsOEJBQWYsRUFBK0M1RixPQUEvQyxDQUFQO0FBQ0QsQ0FId0IsQ0FBM0I7Ozs7QUFNQSxTQUFTZ0csa0JBQVQsR0FBK0I7QUFHN0IsUUFBTUMsUUFBUSxHQUFHLENBQ2Z0RSxPQURlLEVBQ05hLGtCQURNLEVBQ2N3Qiw4QkFEZCxFQUM4Q0csWUFEOUMsRUFFZkcsYUFGZSxFQUVBeUIsa0JBRkEsQ0FBakI7QUFLQUUsRUFBQUEsUUFBUSxDQUFDQyxPQUFULENBQWtCQyxDQUFELElBQU87QUFDdEIsUUFBSUEsQ0FBQyxDQUFDQyxLQUFOLEVBQWE7QUFDWEQsTUFBQUEsQ0FBQyxDQUFDQyxLQUFGLEdBQVUsSUFBSXhFLGdCQUFFQyxPQUFGLENBQVV3RSxLQUFkLEVBQVY7QUFDRDtBQUNGLEdBSkQ7QUFLRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHV0aWwsIGZzLCBwbGlzdCwgbG9nZ2VyIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gJ2FzeW5jYm94JztcbmltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZVBsaXN0RGF0YSB9IGZyb20gJ3BsaXN0JztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHNlbXZlciBmcm9tICdzZW12ZXInO1xuXG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52O1xuXG5jb25zdCBYQ1JVTl9USU1FT1VUID0gMTUwMDA7XG5jb25zdCBYQ09ERV9TVUJESVIgPSBcIi9Db250ZW50cy9EZXZlbG9wZXJcIjtcbmNvbnN0IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMgPSAzO1xuXG5jb25zdCBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKCdYY29kZScpO1xuXG5cbmZ1bmN0aW9uIGhhc0V4cGVjdGVkU3ViRGlyIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnN1YnN0cmluZyhwYXRoLmxlbmd0aCAtIFhDT0RFX1NVQkRJUi5sZW5ndGgpID09PSBYQ09ERV9TVUJESVI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1blhjcnVuQ29tbWFuZCAoYXJncywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZXhlYygneGNydW4nLCBhcmdzLCB7dGltZW91dH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyB0aGUgdHJ1ZSBlcnJvciBjYW4gYmUgaGlkZGVuIHdpdGhpbiB0aGUgc3RkZXJyXG4gICAgaWYgKGVyci5zdGRlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9OiAke2Vyci5zdGRlcnJ9YDtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21TeW1saW5rIChmYWlsTWVzc2FnZSkge1xuICAvLyBOb2RlJ3MgaW52b2NhdGlvbiBvZiB4Y29kZS1zZWxlY3Qgc29tZXRpbWVzIGZsYWtlcyBhbmQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gIC8vIE5vdCBjbGVhciB3aHkuIEFzIGEgd29ya2Fyb3VuZCwgQXBwaXVtIGNhbiByZWxpYWJseSBkZWR1Y2UgdGhlIHZlcnNpb24gaW4gdXNlIGJ5IGNoZWNraW5nXG4gIC8vIHRoZSBsb2NhdGlvbnMgeGNvZGUtc2VsZWN0IHVzZXMgdG8gc3RvcmUgdGhlIHNlbGVjdGVkIHZlcnNpb24ncyBwYXRoLiBUaGlzIHNob3VsZCBiZSAxMDAlXG4gIC8vIHJlbGlhYmxlIHNvIGxvbmcgYXMgdGhlIGxpbmsgbG9jYXRpb25zIHJlbWFpbiB0aGUgc2FtZS4gSG93ZXZlciwgc2luY2Ugd2UncmUgcmVseWluZyBvblxuICAvLyBoYXJkY29kZWQgcGF0aHMsIHRoaXMgYXBwcm9hY2ggd2lsbCBicmVhayB0aGUgbmV4dCB0aW1lIEFwcGxlIGNoYW5nZXMgdGhlIHN5bWxpbmsgbG9jYXRpb24uXG4gIGxvZy53YXJuKGBGaW5kaW5nIFhjb2RlUGF0aCBieSBzeW1saW5rIGJlY2F1c2UgJHtmYWlsTWVzc2FnZX1gKTtcblxuICBjb25zdCBzeW1saW5rUGF0aCA9IFwiL3Zhci9kYi94Y29kZV9zZWxlY3RfbGlua1wiO1xuICBjb25zdCBsZWdhY3lTeW1saW5rUGF0aCA9IFwiL3Vzci9zaGFyZS94Y29kZS1zZWxlY3QveGNvZGVfZGlyX2xpbmtcIjsgLy8gIFhjb2RlIDwgNS54XG4gIGxldCB4Y29kZVBhdGggPSBudWxsO1xuXG4gIC8vIHhjb2RlLXNlbGVjdCBhbGxvd3MgdXNlcnMgdG8gb3ZlcnJpZGUgaXRzIHNldHRpbmdzIHdpdGggdGhlIERFVkVMT1BFUl9ESVIgZW52IHZhcixcbiAgLy8gc28gY2hlY2sgdGhhdCBmaXJzdFxuICBpZiAodXRpbC5oYXNDb250ZW50KGVudi5ERVZFTE9QRVJfRElSKSkge1xuICAgIGNvbnN0IGN1c3RvbVBhdGggPSBoYXNFeHBlY3RlZFN1YkRpcihlbnYuREVWRUxPUEVSX0RJUilcbiAgICAgID8gZW52LkRFVkVMT1BFUl9ESVJcbiAgICAgIDogZW52LkRFVkVMT1BFUl9ESVIgKyBYQ09ERV9TVUJESVI7XG5cbiAgICBpZiAoYXdhaXQgZnMuZXhpc3RzKGN1c3RvbVBhdGgpKSB7XG4gICAgICB4Y29kZVBhdGggPSBjdXN0b21QYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbWVzZyA9IGBDb3VsZCBub3QgZmluZCBwYXRoIHRvIFhjb2RlLCBlbnZpcm9ubWVudCB2YXJpYWJsZSBgICtcbiAgICAgICAgICAgICAgICAgYERFVkVMT1BFUl9ESVIgc2V0IHRvOiAke2Vudi5ERVZFTE9QRVJfRElSfSBgICtcbiAgICAgICAgICAgICAgICAgYGJ1dCBubyBYY29kZSBmb3VuZGA7XG4gICAgICBsb2cud2FybihtZXNnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXdhaXQgZnMuZXhpc3RzKHN5bWxpbmtQYXRoKSkge1xuICAgIHhjb2RlUGF0aCA9IGF3YWl0IGZzLnJlYWRsaW5rKHN5bWxpbmtQYXRoKTtcbiAgfSBlbHNlIGlmIChhd2FpdCBmcy5leGlzdHMobGVnYWN5U3ltbGlua1BhdGgpKSB7XG4gICAgeGNvZGVQYXRoID0gYXdhaXQgZnMucmVhZGxpbmsobGVnYWN5U3ltbGlua1BhdGgpO1xuICB9XG5cbiAgaWYgKHhjb2RlUGF0aCkge1xuICAgIHJldHVybiB4Y29kZVBhdGgucmVwbGFjZShuZXcgUmVnRXhwKFwiLyRcIiksIFwiXCIpLnRyaW0oKTtcbiAgfVxuXG4gIC8vIFdlIHNob3VsZCBvbmx5IGdldCBoZXJlIGlzIHdlIGZhaWxlZCB0byBjYXB0dXJlIHhjb2RlLXNlbGVjdCdzIHN0ZG91dCBhbmQgb3VyXG4gIC8vIG90aGVyIGNoZWNrcyBmYWlsZWQuIEVpdGhlciBBcHBsZSBoYXMgbW92ZWQgdGhlIHN5bWxpbmsgdG8gYSBuZXcgbG9jYXRpb24gb3IgdGhlIHVzZXJcbiAgLy8gaXMgbm90IHVzaW5nIHRoZSBkZWZhdWx0IGluc3RhbGwuIDk5Ljk5OSUgY2hhbmNlIGl0J3MgdGhlIGxhdHRlciwgc28gaXNzdWUgYSB3YXJuaW5nXG4gIC8vIHNob3VsZCB3ZSBldmVyIGhpdCB0aGUgZWRnZSBjYXNlLlxuICBsZXQgbXNnID0gYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gWGNvZGUgYnkgc3ltbGlua3MgbG9jYXRlZCBpbiAke3N5bWxpbmtQYXRofSwgb3IgJHtsZWdhY3lTeW1saW5rUGF0aH1gO1xuICBsb2cud2Fybihtc2cpO1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0UGF0aEZyb21YY29kZVNlbGVjdCAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYygneGNvZGUtc2VsZWN0JywgWyctLXByaW50LXBhdGgnXSwge3RpbWVvdXR9KTtcblxuICAvLyB0cmltIGFuZCByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgY29uc3QgeGNvZGVGb2xkZXJQYXRoID0gc3Rkb3V0LnJlcGxhY2UoL1xcLyQvLCAnJykudHJpbSgpO1xuXG4gIGlmICghdXRpbC5oYXNDb250ZW50KHhjb2RlRm9sZGVyUGF0aCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdygneGNvZGUtc2VsZWN0IHJldHVybmVkIGFuIGVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGF3YWl0IGZzLmV4aXN0cyh4Y29kZUZvbGRlclBhdGgpKSB7XG4gICAgcmV0dXJuIHhjb2RlRm9sZGVyUGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtc2cgPSBgeGNvZGUtc2VsZWN0IGNvdWxkIG5vdCBmaW5kIHhjb2RlLiBQYXRoICcke3hjb2RlRm9sZGVyUGF0aH0nIGRvZXMgbm90IGV4aXN0LmA7XG4gICAgbG9nLmVycm9yQW5kVGhyb3cobXNnKTtcbiAgfVxufVxuXG5jb25zdCBnZXRQYXRoID0gXy5tZW1vaXplKGZ1bmN0aW9uICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAvLyBmaXJzdCB3ZSB0cnkgdXNpbmcgeGNvZGUtc2VsZWN0IHRvIGZpbmQgdGhlIHBhdGhcbiAgLy8gdGhlbiB3ZSB0cnkgdXNpbmcgdGhlIHN5bWxpbmtzIHRoYXQgQXBwbGUgaGFzIGJ5IGRlZmF1bHRcbiAgcmV0dXJuIGdldFBhdGhGcm9tWGNvZGVTZWxlY3QodGltZW91dCkuY2F0Y2goZ2V0UGF0aEZyb21TeW1saW5rKTtcbn0pO1xuXG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyB3ZSB3YW50IHRvIHJlYWQgdGhlIENGQnVuZGxlU2hvcnRWZXJzaW9uU3RyaW5nIGZyb20gWGNvZGUncyBwbGlzdC5cbiAgLy8gSXQgc2hvdWxkIGJlIGluIC9bcm9vdF0vWENvZGUuYXBwL0NvbnRlbnRzL1xuICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoeGNvZGVQYXRoLCBcIi4uXCIsIFwiSW5mby5wbGlzdFwiKTtcblxuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwbGlzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZ2V0IFhjb2RlIHZlcnNpb24uICR7cGxpc3RQYXRofSBkb2VzIG5vdCBleGlzdCBvbiBkaXNrLmApO1xuICB9XG5cbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKHBsaXN0UGF0aCk7XG4gIHJldHVybiBzZW12ZXIuY29lcmNlKHZlcnNpb24uQ0ZCdW5kbGVTaG9ydFZlcnNpb25TdHJpbmcpO1xufVxuXG5jb25zdCBnZXRWZXJzaW9uTWVtb2l6ZWQgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0VmVyc2lvbldpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFZlcnNpb24gKHBhcnNlID0gZmFsc2UsIHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgZ2V0VmVyc2lvbk1lbW9pemVkKHJldHJpZXMsIHRpbWVvdXQpO1xuICAvLyB4Y29kZSB2ZXJzaW9uIHN0cmluZ3MgYXJlIG5vdCBleGFjdGx5IHNlbXZlciBzdHJpbmc6IHBhdGNoIHZlcnNpb25zIG9mIDBcbiAgLy8gYXJlIHJlbW92ZWQgKGUuZy4sICcxMC4wLjAnID0+ICcxMC4wJylcbiAgY29uc3QgdmVyc2lvblN0cmluZyA9IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi52ZXJzaW9uIDogYCR7dmVyc2lvbi5tYWpvcn0uJHt2ZXJzaW9uLm1pbm9yfWA7XG4gIGlmICghcGFyc2UpIHtcbiAgICByZXR1cm4gdmVyc2lvblN0cmluZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmVyc2lvblN0cmluZyxcbiAgICB2ZXJzaW9uRmxvYXQ6IHBhcnNlRmxvYXQodmVyc2lvblN0cmluZyksXG4gICAgbWFqb3I6IHZlcnNpb24ubWFqb3IsXG4gICAgbWlub3I6IHZlcnNpb24ubWlub3IsXG4gICAgcGF0Y2g6IHZlcnNpb24ucGF0Y2ggPiAwID8gdmVyc2lvbi5wYXRjaCA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRDb21tYW5kTGluZVRvb2xzVmVyc2lvbiAoKSB7XG4gIC8vIHRoZXJlIGFyZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0aGF0IHRoZSBDTEkgdG9vbHMgdmVyc2lvbiBoYXMgYmVlblxuICAvLyByZXByZXNlbnRlZC4gVHJ5IHRoZW0gZnJvbSBtb3N0IHJlbGlhYmxlIHRvIGxlYXN0LCBmYWxsaW5nIGRvd24gdGhlIGNoYWluXG4gIGNvbnN0IGdldFZlcnNpb25GdW5jdGlvbnMgPSBbXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgbGV0IHBrZyA9IChhd2FpdCBleGVjKCdwa2d1dGlsJywgWyctLXBrZ3M9Y29tLmFwcGxlLnBrZy5EZXZTREtfLionXSkpLnN0ZG91dDtcbiAgICAgIHJldHVybiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz0ke3BrZy50cmltKCl9YF0pKS5zdGRvdXQ7XG4gICAgfSxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkNMVG9vbHNfRXhlY3V0YWJsZXNgXSkpLnN0ZG91dCxcbiAgICBhc3luYyAoKSA9PiAoYXdhaXQgZXhlYygncGtndXRpbCcsIFtgLS1wa2ctaW5mbz1jb20uYXBwbGUucGtnLkRldmVsb3BlclRvb2xzQ0xJYF0pKS5zdGRvdXQsXG4gIF07XG4gIGxldCBzdGRvdXQ7XG4gIGZvciAobGV0IGdldFZlcnNpb24gb2YgZ2V0VmVyc2lvbkZ1bmN0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBzdGRvdXQgPSBhd2FpdCBnZXRWZXJzaW9uKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIChpZ24pIHtcbiAgICAgIHN0ZG91dCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIHN0ZG91dCBzaG91bGQgaGF2ZSBhIGxpbmUgbGlrZSBgdmVyc2lvbjogOC4wLjAuMC4xLjE0NzI0MzU4ODFgXG4gIGxldCBtYXRjaCA9IC9edmVyc2lvbjogKC4rKSQvbS5leGVjKHN0ZG91dCk7IC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvSFYzeDRkLzFcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgeGNvZGVQYXRoID0gYXdhaXQgZ2V0UGF0aCh0aW1lb3V0KTtcblxuICAvLyBmb3IgaW9zIDggYW5kIHVwLCB0aGUgZmlsZSBleHRlbnNpb24gZm9yIEF1dGlvbWF0aW9uSW5zdHJ1bWVudCBjaGFuZ2VkLlxuICAvLyByYXRoZXIgdGhhbiB3YXN0ZSB0aW1lIGdldHRpbmcgdGhlIGlPU1NES1ZlcnNpb24sIGp1c3QgZ2V0IGJvdGggcGF0aHMgYW5kIHNlZSB3aGljaCBvbmUgZXhpc3RzXG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBbJ3hycGx1Z2luJywgJ2J1bmRsZSddO1xuICBjb25zdCBwYXRoUHJlZml4ID0gcGF0aC5yZXNvbHZlKHhjb2RlUGF0aCwgXCIuLi9BcHBsaWNhdGlvbnMvSW5zdHJ1bWVudHMuYXBwL0NvbnRlbnRzL1BsdWdJbnNcIik7XG4gIGNvbnN0IHBhdGhTdWZmaXggPSBcIkNvbnRlbnRzL1Jlc291cmNlcy9BdXRvbWF0aW9uLnRyYWNldGVtcGxhdGVcIjtcbiAgbGV0IGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMgPSBbXG4gICAgcGF0aC5yZXNvbHZlKHBhdGhQcmVmaXgsIGBBdXRvbWF0aW9uSW5zdHJ1bWVudC4ke2V4dGVuc2lvbnNbMF19YCwgcGF0aFN1ZmZpeCksXG4gICAgcGF0aC5yZXNvbHZlKHBhdGhQcmVmaXgsIGBBdXRvbWF0aW9uSW5zdHJ1bWVudC4ke2V4dGVuc2lvbnNbMV19YCwgcGF0aFN1ZmZpeClcbiAgXTtcblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMF07XG4gIH1cblxuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV0pKSB7XG4gICAgcmV0dXJuIGF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHNbMV07XG4gIH1cblxuICBjb25zdCBtc2cgPSBcIkNvdWxkIG5vdCBmaW5kIEF1dG9tYXRpb24udHJhY2V0ZW1wbGF0ZSBpbiBhbnkgb2YgdGhlIGZvbGxvd2luZ1wiICtcbiAgICAgICAgICAgICAgYGxvY2F0aW9ucyAke2F1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aHMudG9TdHJpbmcoKX1gO1xuICBsb2cuZXJyb3IobXNnKTtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cbn1cblxuY29uc3QgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoID0gXy5tZW1vaXplKFxuICBmdW5jdGlvbiAocmV0cmllcyA9IERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gICAgcmV0dXJuIHJldHJ5KHJldHJpZXMsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1heElPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGF3YWl0IGdldFZlcnNpb24oZmFsc2UsIERFRkFVTFRfTlVNQkVSX09GX1JFVFJJRVMsIHRpbWVvdXQpO1xuICBpZiAodmVyc2lvblswXSA9PT0gJzQnKSB7XG4gICAgcmV0dXJuICc2LjEnO1xuICB9XG5cbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnaXBob25lc2ltdWxhdG9yJywgJy0tc2hvdy1zZGstdmVyc2lvbiddO1xuICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHJ1blhjcnVuQ29tbWFuZChhcmdzLCB0aW1lb3V0KTtcblxuICBjb25zdCBzZGtWZXJzaW9uID0gc3Rkb3V0LnRyaW0oKTtcbiAgY29uc3QgbWF0Y2ggPSAvXFxkLlxcZC8uZXhlYyhzdGRvdXQpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHhjcnVuIHJldHVybmVkIGEgbm9uLW51bWVyaWMgaU9TIFNESyB2ZXJzaW9uOiAnJHtzZGtWZXJzaW9ufSdgKTtcbiAgfVxuXG4gIHJldHVybiBzZGtWZXJzaW9uO1xufVxuXG5jb25zdCBnZXRNYXhJT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LCB0aW1lb3V0KTtcbiAgfVxuKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSAodGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgY29uc3QgYXJncyA9IFsnLS1zZGsnLCAnYXBwbGV0dnNpbXVsYXRvcicsICctLXNob3ctc2RrLXZlcnNpb24nXTtcbiAgY29uc3Qge3N0ZG91dH0gPSBhd2FpdCBydW5YY3J1bkNvbW1hbmQoYXJncywgdGltZW91dCk7XG5cbiAgY29uc3Qgc2RrVmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKGlzTmFOKHBhcnNlRmxvYXQoc2RrVmVyc2lvbikpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGB4Y3J1biByZXR1cm5lZCBhIG5vbi1udW1lcmljIHR2T1MgU0RLIHZlcnNpb246ICcke3Nka1ZlcnNpb259J2ApO1xuICB9XG5cbiAgcmV0dXJuIHNka1ZlcnNpb247XG59XG5cbmNvbnN0IGdldE1heFRWT1NTREsgPSBfLm1lbW9pemUoXG4gIGZ1bmN0aW9uIChyZXRyaWVzID0gREVGQVVMVF9OVU1CRVJfT0ZfUkVUUklFUywgdGltZW91dCA9IFhDUlVOX1RJTUVPVVQpIHtcbiAgICByZXR1cm4gcmV0cnkocmV0cmllcywgZ2V0TWF4VFZPU1NES1dpdGhvdXRSZXRyeSwgdGltZW91dCk7XG4gIH1cbik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbm5lY3RlZERldmljZXMgKHRpbWVvdXQgPSBYQ1JVTl9USU1FT1VUKSB7XG4gIGNvbnN0IGNtZCA9ICcvdXNyL3NiaW4vc3lzdGVtX3Byb2ZpbGVyJztcbiAgY29uc3QgYXJncyA9IFsnLXhtbCcsICdTUFVTQkRhdGFUeXBlJ107XG4gIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMoY21kLCBhcmdzLCB7dGltZW91dH0pO1xuICBsZXQgcGxpc3RDb250ZW50ID0gcGFyc2VQbGlzdERhdGEoc3Rkb3V0KTtcblxuICBsZXQgZGV2aWNlc0ZvdW5kID0gW107XG4gIGxldCBlbnRyaWVzVG9TZWFyY2ggPSBbcGxpc3RDb250ZW50WzBdXTtcbiAgd2hpbGUgKGVudHJpZXNUb1NlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGN1cnJlbnRFbnRyeSA9IGVudHJpZXNUb1NlYXJjaC5wb3AoKTtcbiAgICBpZiAoY3VycmVudEVudHJ5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGVudHJpZXNUb1NlYXJjaCA9IGVudHJpZXNUb1NlYXJjaC5jb25jYXQoY3VycmVudEVudHJ5KTtcbiAgICB9IGVsc2UgaWYgKChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDQpID09PSBcImlQYWRcIikgfHxcbiAgICAgICAgICAgICAgIChjdXJyZW50RW50cnkuX25hbWUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50RW50cnkuX25hbWUuc3Vic3RyaW5nKDAsIDYpID09PSBcImlQaG9uZVwiKSB8fFxuICAgICAgICAgICAgICAgKGN1cnJlbnRFbnRyeS5fbmFtZSAmJiBfLmluY2x1ZGVzKGN1cnJlbnRFbnRyeS5fbmFtZSwgXCJBcHBsZSBUVlwiKSkpIHtcbiAgICAgIGxldCBkZXZpY2VJbmZvID0ge1xuICAgICAgICBuYW1lOiBjdXJyZW50RW50cnkuX25hbWUsXG4gICAgICAgIHVkaWQ6IGN1cnJlbnRFbnRyeS5zZXJpYWxfbnVtLFxuICAgICAgICBwcm9kdWN0SWQ6IGN1cnJlbnRFbnRyeS5wcm9kdWN0X2lkLFxuICAgICAgICBkZXZpY2VWZXJzaW9uOiBjdXJyZW50RW50cnkuYmNkX2RldmljZVxuICAgICAgfTtcbiAgICAgIGRldmljZXNGb3VuZC5wdXNoKGRldmljZUluZm8pO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEVudHJ5Ll9pdGVtcykge1xuICAgICAgZW50cmllc1RvU2VhcmNoID0gZW50cmllc1RvU2VhcmNoLmNvbmNhdChjdXJyZW50RW50cnkuX2l0ZW1zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRldmljZXNGb3VuZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0SW5zdHJ1bWVudHNQYXRoV2l0aG91dFJldHJ5ICh0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICBjb25zdCBhcmdzID0gWyctZmluZCcsICdpbnN0cnVtZW50cyddO1xuICBsZXQge3N0ZG91dH0gPSBhd2FpdCBydW5YY3J1bkNvbW1hbmQoYXJncywgdGltZW91dCk7XG5cbiAgaWYgKCFzdGRvdXQpIHtcbiAgICBzdGRvdXQgPSBcIlwiO1xuICB9XG5cbiAgbGV0IGluc3RydW1lbnRzUGF0aCA9IHN0ZG91dC50cmltKCk7XG5cbiAgaWYgKCFpbnN0cnVtZW50c1BhdGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHBhdGggdG8gaW5zdHJ1bWVudHMgYmluYXJ5IHVzaW5nICd4Y3J1biAke2FyZ3Muam9pbignICcpfSdgKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0cnVtZW50c1BhdGg7XG59XG5cbmNvbnN0IGdldEluc3RydW1lbnRzUGF0aCA9IF8ubWVtb2l6ZShcbiAgZnVuY3Rpb24gKHJldHJpZXMgPSBERUZBVUxUX05VTUJFUl9PRl9SRVRSSUVTLCB0aW1lb3V0ID0gWENSVU5fVElNRU9VVCkge1xuICAgIHJldHVybiByZXRyeShyZXRyaWVzLCBnZXRJbnN0cnVtZW50c1BhdGhXaXRob3V0UmV0cnksIHRpbWVvdXQpO1xuICB9XG4pO1xuXG5mdW5jdGlvbiBjbGVhckludGVybmFsQ2FjaGUgKCkge1xuXG4gIC8vIG1lbW9pemVkIGZ1bmN0aW9uc1xuICBjb25zdCBtZW1vaXplZCA9IFtcbiAgICBnZXRQYXRoLCBnZXRWZXJzaW9uTWVtb2l6ZWQsIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aCwgZ2V0TWF4SU9TU0RLLFxuICAgIGdldE1heFRWT1NTREssIGdldEluc3RydW1lbnRzUGF0aCxcbiAgXTtcblxuICBtZW1vaXplZC5mb3JFYWNoKChmKSA9PiB7XG4gICAgaWYgKGYuY2FjaGUpIHtcbiAgICAgIGYuY2FjaGUgPSBuZXcgXy5tZW1vaXplLkNhY2hlKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0UGF0aCwgZ2V0VmVyc2lvbiwgZ2V0QXV0b21hdGlvblRyYWNlVGVtcGxhdGVQYXRoLCBnZXRNYXhJT1NTREssXG4gIGdldEF1dG9tYXRpb25UcmFjZVRlbXBsYXRlUGF0aFdpdGhvdXRSZXRyeSwgZ2V0TWF4SU9TU0RLV2l0aG91dFJldHJ5LFxuICBnZXRDb25uZWN0ZWREZXZpY2VzLCBjbGVhckludGVybmFsQ2FjaGUsIGdldEluc3RydW1lbnRzUGF0aCxcbiAgZ2V0Q29tbWFuZExpbmVUb29sc1ZlcnNpb24sIGdldE1heFRWT1NTREssIGdldE1heFRWT1NTREtXaXRob3V0UmV0cnksXG59O1xuIl0sImZpbGUiOiJsaWIveGNvZGUuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
