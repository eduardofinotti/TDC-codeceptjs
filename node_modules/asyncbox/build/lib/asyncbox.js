"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sleep = sleep;
exports.retry = retry;
exports.nodeify = nodeify;
exports.nodeifyAll = nodeifyAll;
exports.retryInterval = retryInterval;
exports.asyncify = asyncify;
exports.parallel = parallel;
exports.asyncmap = asyncmap;
exports.asyncfilter = asyncfilter;
exports.waitForCondition = waitForCondition;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _es6Mapify = require("es6-mapify");

var _lodash = _interopRequireDefault(require("lodash"));

function sleep(_x) {
  return _sleep.apply(this, arguments);
}

function _sleep() {
  _sleep = (0, _asyncToGenerator2.default)(function* (ms) {
    return yield _bluebird.default.delay(ms);
  });
  return _sleep.apply(this, arguments);
}

function retry(_x2, _x3) {
  return _retry.apply(this, arguments);
}

function _retry() {
  _retry = (0, _asyncToGenerator2.default)(function* (times, fn, ...args) {
    let tries = 0;
    let done = false;
    let res = null;

    while (!done && tries < times) {
      tries++;

      try {
        res = yield fn(...args);
        done = true;
      } catch (err) {
        if (tries >= times) {
          throw err;
        }
      }
    }

    return res;
  });
  return _retry.apply(this, arguments);
}

function retryInterval(_x4, _x5, _x6) {
  return _retryInterval.apply(this, arguments);
}

function _retryInterval() {
  _retryInterval = (0, _asyncToGenerator2.default)(function* (times, sleepMs, fn, ...args) {
    let count = 0;

    let wrapped = function () {
      var _ref = (0, _asyncToGenerator2.default)(function* () {
        count++;
        let res;

        try {
          res = yield fn(...args);
        } catch (e) {
          if (count !== times) {
            yield sleep(sleepMs);
          }

          throw e;
        }

        return res;
      });

      return function wrapped() {
        return _ref.apply(this, arguments);
      };
    }();

    return yield retry(times, wrapped);
  });
  return _retryInterval.apply(this, arguments);
}

function parallel(_x7) {
  return _parallel.apply(this, arguments);
}

function _parallel() {
  _parallel = (0, _asyncToGenerator2.default)(function* (promises) {
    return yield _bluebird.default.all(promises);
  });
  return _parallel.apply(this, arguments);
}

function nodeify(promisey, cb) {
  return _bluebird.default.resolve(promisey).nodeify(cb);
}

function nodeifyAll(promiseyMap) {
  let cbMap = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _es6Mapify.mapify)(promiseyMap)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      let _step$value = (0, _slicedToArray2.default)(_step.value, 2),
          name = _step$value[0],
          fn = _step$value[1];

      cbMap[name] = function (...args) {
        let _cb = args.slice(-1)[0];
        args = args.slice(0, -1);
        nodeify(fn(...args), _cb);
      };
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return cbMap;
}

function asyncify(fn, ...args) {
  _bluebird.default.resolve(fn(...args)).done();
}

function asyncmap(_x8, _x9) {
  return _asyncmap.apply(this, arguments);
}

function _asyncmap() {
  _asyncmap = (0, _asyncToGenerator2.default)(function* (coll, mapper, runInParallel = true) {
    if (runInParallel) {
      return parallel(coll.map(mapper));
    }

    let newColl = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = coll[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        let item = _step2.value;
        newColl.push((yield mapper(item)));
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return newColl;
  });
  return _asyncmap.apply(this, arguments);
}

function asyncfilter(_x10, _x11) {
  return _asyncfilter.apply(this, arguments);
}

function _asyncfilter() {
  _asyncfilter = (0, _asyncToGenerator2.default)(function* (coll, filter, runInParallel = true) {
    let newColl = [];

    if (runInParallel) {
      let bools = yield parallel(coll.map(filter));

      for (let i = 0; i < coll.length; i++) {
        if (bools[i]) {
          newColl.push(coll[i]);
        }
      }
    } else {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = coll[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          let item = _step3.value;

          if (yield filter(item)) {
            newColl.push(item);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    return newColl;
  });
  return _asyncfilter.apply(this, arguments);
}

function waitForCondition(_x12) {
  return _waitForCondition.apply(this, arguments);
}

function _waitForCondition() {
  _waitForCondition = (0, _asyncToGenerator2.default)(function* (condFn, opts = {}) {
    _lodash.default.defaults(opts, {
      waitMs: 5000,
      intervalMs: 500
    });

    let debug = opts.logger ? opts.logger.debug.bind(opts.logger) : _lodash.default.noop;
    let begunAt = Date.now();
    let endAt = begunAt + opts.waitMs;

    let spin = function () {
      var _ref2 = (0, _asyncToGenerator2.default)(function* () {
        const result = yield condFn();

        if (result) {
          return result;
        }

        let now = Date.now();
        let waited = now - begunAt;

        if (now < endAt) {
          debug(`Waited for ${waited} ms so far`);
          yield _bluebird.default.delay(opts.intervalMs);
          return yield spin();
        }

        throw new Error(`Condition unmet after ${waited} ms. Timing out.`);
      });

      return function spin() {
        return _ref2.apply(this, arguments);
      };
    }();

    return yield spin();
  });
  return _waitForCondition.apply(this, arguments);
}require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9hc3luY2JveC5qcyJdLCJuYW1lcyI6WyJzbGVlcCIsIm1zIiwiQiIsImRlbGF5IiwicmV0cnkiLCJ0aW1lcyIsImZuIiwiYXJncyIsInRyaWVzIiwiZG9uZSIsInJlcyIsImVyciIsInJldHJ5SW50ZXJ2YWwiLCJzbGVlcE1zIiwiY291bnQiLCJ3cmFwcGVkIiwiZSIsInBhcmFsbGVsIiwicHJvbWlzZXMiLCJhbGwiLCJub2RlaWZ5IiwicHJvbWlzZXkiLCJjYiIsInJlc29sdmUiLCJub2RlaWZ5QWxsIiwicHJvbWlzZXlNYXAiLCJjYk1hcCIsIm5hbWUiLCJfY2IiLCJzbGljZSIsImFzeW5jaWZ5IiwiYXN5bmNtYXAiLCJjb2xsIiwibWFwcGVyIiwicnVuSW5QYXJhbGxlbCIsIm1hcCIsIm5ld0NvbGwiLCJpdGVtIiwicHVzaCIsImFzeW5jZmlsdGVyIiwiZmlsdGVyIiwiYm9vbHMiLCJpIiwibGVuZ3RoIiwid2FpdEZvckNvbmRpdGlvbiIsImNvbmRGbiIsIm9wdHMiLCJfIiwiZGVmYXVsdHMiLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiZGVidWciLCJsb2dnZXIiLCJiaW5kIiwibm9vcCIsImJlZ3VuQXQiLCJEYXRlIiwibm93IiwiZW5kQXQiLCJzcGluIiwicmVzdWx0Iiwid2FpdGVkIiwiRXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQTs7QUFDQTs7QUFDQTs7U0FFZUEsSzs7Ozs7MkNBQWYsV0FBc0JDLEVBQXRCLEVBQTBCO0FBQ3hCLGlCQUFhQyxrQkFBRUMsS0FBRixDQUFRRixFQUFSLENBQWI7QUFDRCxHOzs7O1NBRWNHLEs7Ozs7OzJDQUFmLFdBQXNCQyxLQUF0QixFQUE2QkMsRUFBN0IsRUFBaUMsR0FBR0MsSUFBcEMsRUFBMEM7QUFDeEMsUUFBSUMsS0FBSyxHQUFHLENBQVo7QUFDQSxRQUFJQyxJQUFJLEdBQUcsS0FBWDtBQUNBLFFBQUlDLEdBQUcsR0FBRyxJQUFWOztBQUNBLFdBQU8sQ0FBQ0Qs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IHRyYW5zcGlsZTptYWluXG5cbmltcG9ydCBCIGZyb20gJ2JsdWViaXJkJztcbmltcG9ydCB7IG1hcGlmeSB9IGZyb20gJ2VzNi1tYXBpZnknO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuYXN5bmMgZnVuY3Rpb24gc2xlZXAgKG1zKSB7XG4gIHJldHVybiBhd2FpdCBCLmRlbGF5KG1zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmV0cnkgKHRpbWVzLCBmbiwgLi4uYXJncykge1xuICBsZXQgdHJpZXMgPSAwO1xuICBsZXQgZG9uZSA9IGZhbHNlO1xuICBsZXQgcmVzID0gbnVsbDtcbiAgd2hpbGUgKCFkb25lICYmIHRyaWVzIDwgdGltZXMpIHtcbiAgICB0cmllcysrO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRyaWVzID49IHRpbWVzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmV0cnlJbnRlcnZhbCAodGltZXMsIHNsZWVwTXMsIGZuLCAuLi5hcmdzKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCB3cmFwcGVkID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvdW50Kys7XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXdhaXQgZm4oLi4uYXJncyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZG8gbm90IHBhdXNlIHdoZW4gZmluaXNoZWQgdGhlIGxhc3QgcmV0cnlcbiAgICAgIGlmIChjb3VudCAhPT0gdGltZXMpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAoc2xlZXBNcyk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICByZXR1cm4gYXdhaXQgcmV0cnkodGltZXMsIHdyYXBwZWQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJhbGxlbCAocHJvbWlzZXMpIHtcbiAgcmV0dXJuIGF3YWl0IEIuYWxsKHByb21pc2VzKTtcbn1cblxuZnVuY3Rpb24gbm9kZWlmeSAocHJvbWlzZXksIGNiKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJvbWlzZS9wcmVmZXItYXdhaXQtdG8tY2FsbGJhY2tzXG4gIHJldHVybiBCLnJlc29sdmUocHJvbWlzZXkpLm5vZGVpZnkoY2IpO1xufVxuXG5mdW5jdGlvbiBub2RlaWZ5QWxsIChwcm9taXNleU1hcCkge1xuICBsZXQgY2JNYXAgPSB7fTtcbiAgZm9yIChsZXQgW25hbWUsIGZuXSBvZiBtYXBpZnkocHJvbWlzZXlNYXApKSB7XG4gICAgLypqc2hpbnQgLVcwODMgKi9cbiAgICBjYk1hcFtuYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBsZXQgX2NiID0gYXJncy5zbGljZSgtMSlbMF07XG4gICAgICBhcmdzID0gYXJncy5zbGljZSgwLCAtMSk7XG4gICAgICBub2RlaWZ5KGZuKC4uLmFyZ3MpLCBfY2IpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNiTWFwO1xufVxuXG5mdW5jdGlvbiBhc3luY2lmeSAoZm4sIC4uLmFyZ3MpIHtcbiAgQi5yZXNvbHZlKGZuKC4uLmFyZ3MpKS5kb25lKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jbWFwIChjb2xsLCBtYXBwZXIsIHJ1bkluUGFyYWxsZWwgPSB0cnVlKSB7XG4gIGlmIChydW5JblBhcmFsbGVsKSB7XG4gICAgcmV0dXJuIHBhcmFsbGVsKGNvbGwubWFwKG1hcHBlcikpO1xuICB9XG5cbiAgbGV0IG5ld0NvbGwgPSBbXTtcbiAgZm9yIChsZXQgaXRlbSBvZiBjb2xsKSB7XG4gICAgbmV3Q29sbC5wdXNoKGF3YWl0IG1hcHBlcihpdGVtKSk7XG4gIH1cbiAgcmV0dXJuIG5ld0NvbGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jZmlsdGVyIChjb2xsLCBmaWx0ZXIsIHJ1bkluUGFyYWxsZWwgPSB0cnVlKSB7XG4gIGxldCBuZXdDb2xsID0gW107XG4gIGlmIChydW5JblBhcmFsbGVsKSB7XG4gICAgbGV0IGJvb2xzID0gYXdhaXQgcGFyYWxsZWwoY29sbC5tYXAoZmlsdGVyKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9vbHNbaV0pIHtcbiAgICAgICAgbmV3Q29sbC5wdXNoKGNvbGxbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGNvbGwpIHtcbiAgICAgIGlmIChhd2FpdCBmaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgbmV3Q29sbC5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3Q29sbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNvbmRpdGlvbiAoY29uZEZuLCBvcHRzID0ge30pIHtcbiAgXy5kZWZhdWx0cyhvcHRzLCB7XG4gICAgd2FpdE1zOiA1MDAwLFxuICAgIGludGVydmFsTXM6IDUwMCxcbiAgfSk7XG4gIGxldCBkZWJ1ZyA9IG9wdHMubG9nZ2VyID8gb3B0cy5sb2dnZXIuZGVidWcuYmluZChvcHRzLmxvZ2dlcikgOiBfLm5vb3A7XG4gIGxldCBiZWd1bkF0ID0gRGF0ZS5ub3coKTtcbiAgbGV0IGVuZEF0ID0gYmVndW5BdCArIG9wdHMud2FpdE1zO1xuICBsZXQgc3BpbiA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25kRm4oKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsZXQgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgd2FpdGVkID0gbm93IC0gYmVndW5BdDtcbiAgICBpZiAobm93IDwgZW5kQXQpIHtcbiAgICAgIGRlYnVnKGBXYWl0ZWQgZm9yICR7d2FpdGVkfSBtcyBzbyBmYXJgKTtcbiAgICAgIGF3YWl0IEIuZGVsYXkob3B0cy5pbnRlcnZhbE1zKTtcbiAgICAgIHJldHVybiBhd2FpdCBzcGluKCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ29uZGl0aW9uIHVubWV0IGFmdGVyICR7d2FpdGVkfSBtcy4gVGltaW5nIG91dC5gKTtcbiAgfTtcbiAgcmV0dXJuIGF3YWl0IHNwaW4oKTtcbn1cblxuZXhwb3J0IHtcbiAgc2xlZXAsIHJldHJ5LCBub2RlaWZ5LCBub2RlaWZ5QWxsLCByZXRyeUludGVydmFsLCBhc3luY2lmeSwgcGFyYWxsZWwsXG4gIGFzeW5jbWFwLCBhc3luY2ZpbHRlciwgd2FpdEZvckNvbmRpdGlvblxufTtcbiJdLCJmaWxlIjoibGliL2FzeW5jYm94LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
