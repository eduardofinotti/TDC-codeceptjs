"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OptionalFfmpegCommandCheck = exports.OptionalOpencv4nodejsCommandCheck = exports.OptionalPythonVersionCheck = exports.NodeVersionCheck = exports.NodeBinaryCheck = void 0;

require("source-map-support/register");

var _utils = require("./utils");

var _teen_process = require("teen_process");

var _doctor = require("./doctor");

var _nodeDetector = _interopRequireDefault(require("./node-detector"));

var _logger = _interopRequireDefault(require("./logger"));

var _os = require("os");

var _appiumSupport = require("appium-support");

let checks = [];

class NodeBinaryCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let nodePath = await _nodeDetector.default.detect();
    return nodePath ? (0, _utils.ok)(`The Node.js binary was found at: ${nodePath}`) : (0, _utils.nok)('The Node.js binary was NOT found!');
  }

  fix() {
    return `Manually setup Node.js.`;
  }

}

exports.NodeBinaryCheck = NodeBinaryCheck;
checks.push(new NodeBinaryCheck());

class NodeVersionCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let nodePath = await _nodeDetector.default.detect();

    if (!nodePath) {
      return (0, _utils.nok)('Node is not installed, so no version to check!');
    }

    let {
      stdout
    } = await (0, _teen_process.exec)(nodePath, ['--version']);
    let versionString = stdout.replace('v', '').trim();
    let version = parseInt(versionString, 10);

    if (Number.isNaN(version)) {
      return (0, _utils.nok)(`Unable to find node version (version = '${versionString}')`);
    }

    return version >= 4 ? (0, _utils.ok)(`Node version is ${versionString}`) : (0, _utils.nok)('Node version should be at least 4!');
  }

  fix() {
    return `Manually upgrade Node.js.`;
  }

}

exports.NodeVersionCheck = NodeVersionCheck;
checks.push(new NodeVersionCheck());

class OptionalPythonVersionCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const pythonPath = await (0, _utils.resolveExecutablePath)(`python${_appiumSupport.system.isWindows() ? `.EXE` : ''}`);

    if (!pythonPath) {
      return (0, _utils.nokOptional)(`Python required by node-gyp (used by heapdump) not found in PATH: ${process.env.PATH}`);
    }

    const {
      stdout,
      stderr
    } = await (0, _teen_process.exec)(pythonPath, ['-V']);
    let versionString = `${stdout} ${stderr}`.match(/Python (\d(\.\d+)*)/g);

    if (versionString) {
      versionString = versionString.pop().replace('Python ', '');
    }

    const version = parseInt(versionString, 10);

    if (Number.isNaN(version)) {
      return (0, _utils.nokOptional)(`Unable to identify Python version correctly (version = '${versionString}') at ${pythonPath}. Please make sure your Python environment in PATH: ${process.env.PATH}. node-gyp (used by heapdump) requires Python 2.x`);
    }

    return version === 2 ? (0, _utils.okOptional)(`Python required by node-gyp (used by heapdump) is installed at: ${pythonPath}. Installed version is: ${versionString}`) : (0, _utils.nokOptional)('Python version required by node-gyp (used by heapdump) should be 2.x');
  }

  fix() {
    return `Manually configure Python 2.x environment. node-gyp which is NodeJS toolchain requires Python 2.x`;
  }

}

exports.OptionalPythonVersionCheck = OptionalPythonVersionCheck;
checks.push(new OptionalPythonVersionCheck());

class OptionalOpencv4nodejsCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let stdout = '';
    const packageName = 'opencv4nodejs';
    const npmPath = await (0, _utils.resolveExecutablePath)(`npm${_appiumSupport.system.isWindows() ? `.cmd` : ''}`);

    if (!npmPath) {
      return (0, _utils.nokOptional)(`'npm' binary not found in PATH: ${process.env.PATH}`);
    }

    try {
      ({
        stdout
      } = await (0, _teen_process.exec)(npmPath, ['list', '-g', packageName]));
    } catch (err) {
      _logger.default.debug(err);
    }

    if (stdout.includes(packageName)) {
      const lines = stdout.split(_os.EOL);
      const openvcLib = lines.find(function (line) {
        return line.includes(`${packageName}@`);
      });
      return openvcLib ? (0, _utils.okOptional)(`${packageName} is installed at: ${lines[0]}. Installed version is: ${openvcLib.match(/(\d(\.\d+)*)/g).pop()}`) : (0, _utils.okOptional)(`${packageName} is probably installed at: ${lines[0]}.`);
    }

    return (0, _utils.nokOptional)(`${packageName} cannot be found.`);
  }

  async fix() {
    return 'Why opencv4nodejs is needed and how to install it: https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/image-comparison.md';
  }

}

exports.OptionalOpencv4nodejsCommandCheck = OptionalOpencv4nodejsCommandCheck;
checks.push(new OptionalOpencv4nodejsCommandCheck());

class OptionalFfmpegCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const ffmpegPath = await (0, _utils.resolveExecutablePath)('ffmpeg');
    return ffmpegPath ? (0, _utils.okOptional)(`ffmpeg is installed at: ${ffmpegPath}. ${(await (0, _teen_process.exec)('ffmpeg', ['-version'])).stdout.split(_os.EOL)[0]}`) : (0, _utils.nokOptional)('ffmpeg cannot be found');
  }

  async fix() {
    return 'ffmpeg is needed to record screen features. Please read https://www.ffmpeg.org/ to install it';
  }

}

exports.OptionalFfmpegCommandCheck = OptionalFfmpegCommandCheck;
checks.push(new OptionalFfmpegCommandCheck());
var _default = checks;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9nZW5lcmFsLmpzIl0sIm5hbWVzIjpbImNoZWNrcyIsIk5vZGVCaW5hcnlDaGVjayIsIkRvY3RvckNoZWNrIiwiZGlhZ25vc2UiLCJub2RlUGF0aCIsIk5vZGVEZXRlY3RvciIsImRldGVjdCIsImZpeCIsInB1c2giLCJOb2RlVmVyc2lvbkNoZWNrIiwic3Rkb3V0IiwidmVyc2lvblN0cmluZyIsInJlcGxhY2UiLCJ0cmltIiwidmVyc2lvbiIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJPcHRpb25hbFB5dGhvblZlcnNpb25DaGVjayIsInB5dGhvblBhdGgiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJwcm9jZXNzIiwiZW52IiwiUEFUSCIsInN0ZGVyciIsIm1hdGNoIiwicG9wIiwiT3B0aW9uYWxPcGVuY3Y0bm9kZWpzQ29tbWFuZENoZWNrIiwicGFja2FnZU5hbWUiLCJucG1QYXRoIiwiZXJyIiwibG9nIiwiZGVidWciLCJpbmNsdWRlcyIsImxpbmVzIiwic3BsaXQiLCJFT0wiLCJvcGVudmNMaWIiLCJmaW5kIiwibGluZSIsIk9wdGlvbmFsRmZtcGVnQ29tbWFuZENoZWNrIiwiZmZtcGVnUGF0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxJQUFJQSxNQUFNLEdBQUcsRUFBYjs7QUFHQSxNQUFNQyxlQUFOLFNBQThCQyxtQkFBOUIsQ0FBMEM7QUFDeEMsUUFBTUMsUUFBTixHQUFrQjtBQUNoQixRQUFJQyxRQUFRLEdBQUcsTUFBTUMsc0JBQWFDLE1BQWIsRUFBckI7QUFDQSxXQUFPRixRQUFRLEdBQUcsZUFBSSxvQ0FBbUNBLFFBQVMsRUFBaEQsQ0FBSCxHQUNiLGdCQUFJLG1DQUFKLENBREY7QUFFRDs7QUFFREcsRUFBQUEsR0FBRyxHQUFJO0FBQ0wsV0FBUSx5QkFBUjtBQUNEOztBQVR1Qzs7O0FBVzFDUCxNQUFNLENBQUNRLElBQVAsQ0FBWSxJQUFJ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LENBQXFEO0FBQ25ELFFBQU1DLFFBQU4sR0FBa0I7QUFDaEIsVUFBTXVDLFVBQVUsR0FBRyxNQUFNLGtDQUFzQixRQUF0QixDQUF6QjtBQUNBLFdBQU9BLFVBQVUsR0FDYix1QkFBWSwyQkFBMEJBLFVBQVcsS0FBSSxDQUFDLE1BQU0sd0JBQUssUUFBTCxFQUFlLENBQUMsVUFBRCxDQUFmLENBQVAsRUFBcUNoQyxNQUFyQyxDQUE0QzBCLEtBQTVDLENBQWtEQyxPQUFsRCxFQUF1RCxDQUF2RCxDQUEwRCxFQUEvRyxDQURhLEdBRWIsd0JBQVksd0JBQVosQ0FGSjtBQUdEOztBQUVELFFBQU05QixHQUFOLEdBQWE7QUFDWCxXQUFPLCtGQUFQO0FBQ0Q7O0FBVmtEOzs7QUFZckRQLE1BQU0sQ0FBQ1EsSUFBUCxDQUFZLElBQUlpQywwQkFBSixFQUFaO2VBSWV6QyxNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb2ssIG5vaywgb2tPcHRpb25hbCwgbm9rT3B0aW9uYWwsIHJlc29sdmVFeGVjdXRhYmxlUGF0aCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgeyBEb2N0b3JDaGVjayB9IGZyb20gJy4vZG9jdG9yJztcbmltcG9ydCBOb2RlRGV0ZWN0b3IgZnJvbSAnLi9ub2RlLWRldGVjdG9yJztcbmltcG9ydCBsb2cgZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgRU9MIH0gZnJvbSAnb3MnO1xuaW1wb3J0IHsgc3lzdGVtIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuXG5sZXQgY2hlY2tzID0gW107XG5cbi8vIE5vZGUgQmluYXJ5XG5jbGFzcyBOb2RlQmluYXJ5Q2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBsZXQgbm9kZVBhdGggPSBhd2FpdCBOb2RlRGV0ZWN0b3IuZGV0ZWN0KCk7XG4gICAgcmV0dXJuIG5vZGVQYXRoID8gb2soYFRoZSBOb2RlLmpzIGJpbmFyeSB3YXMgZm91bmQgYXQ6ICR7bm9kZVBhdGh9YCkgOlxuICAgICAgbm9rKCdUaGUgTm9kZS5qcyBiaW5hcnkgd2FzIE5PVCBmb3VuZCEnKTtcbiAgfVxuXG4gIGZpeCAoKSB7XG4gICAgcmV0dXJuIGBNYW51YWxseSBzZXR1cCBOb2RlLmpzLmA7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBOb2RlQmluYXJ5Q2hlY2soKSk7XG5cbi8vIE5vZGUgdmVyc2lvblxuY2xhc3MgTm9kZVZlcnNpb25DaGVjayBleHRlbmRzIERvY3RvckNoZWNrIHtcbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGxldCBub2RlUGF0aCA9IGF3YWl0IE5vZGVEZXRlY3Rvci5kZXRlY3QoKTtcbiAgICBpZiAoIW5vZGVQYXRoKSB7XG4gICAgICByZXR1cm4gbm9rKCdOb2RlIGlzIG5vdCBpbnN0YWxsZWQsIHNvIG5vIHZlcnNpb24gdG8gY2hlY2shJyk7XG4gICAgfVxuICAgIGxldCB7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMobm9kZVBhdGgsIFsnLS12ZXJzaW9uJ10pO1xuICAgIGxldCB2ZXJzaW9uU3RyaW5nID0gc3Rkb3V0LnJlcGxhY2UoJ3YnLCAnJykudHJpbSgpO1xuICAgIGxldCB2ZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblN0cmluZywgMTApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBub2soYFVuYWJsZSB0byBmaW5kIG5vZGUgdmVyc2lvbiAodmVyc2lvbiA9ICcke3ZlcnNpb25TdHJpbmd9JylgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlcnNpb24gPj0gNCA/IG9rKGBOb2RlIHZlcnNpb24gaXMgJHt2ZXJzaW9uU3RyaW5nfWApIDpcbiAgICAgIG5vaygnTm9kZSB2ZXJzaW9uIHNob3VsZCBiZSBhdCBsZWFzdCA0IScpO1xuICB9XG5cbiAgZml4ICgpIHtcbiAgICByZXR1cm4gYE1hbnVhbGx5IHVwZ3JhZGUgTm9kZS5qcy5gO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgTm9kZVZlcnNpb25DaGVjaygpKTtcblxuLy8gUHl0aG9uIHZlcnNpb24gY2hlY2sgd2hpY2ggaXMgcmVxdWlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlLWd5cFxuY2xhc3MgT3B0aW9uYWxQeXRob25WZXJzaW9uQ2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBjb25zdCBweXRob25QYXRoID0gYXdhaXQgcmVzb2x2ZUV4ZWN1dGFibGVQYXRoKGBweXRob24ke3N5c3RlbS5pc1dpbmRvd3MoKSA/IGAuRVhFYCA6ICcnfWApO1xuICAgIGlmICghcHl0aG9uUGF0aCkge1xuICAgICAgcmV0dXJuIG5va09wdGlvbmFsKGBQeXRob24gcmVxdWlyZWQgYnkgbm9kZS1neXAgKHVzZWQgYnkgaGVhcGR1bXApIG5vdCBmb3VuZCBpbiBQQVRIOiAke3Byb2Nlc3MuZW52LlBBVEh9YCk7XG4gICAgfVxuXG4gICAgLy8gSXQgY2FuIHJldHVybiB2ZXJzaW9uIG51bWJlciBhcyBzdGRlcnJcbiAgICBjb25zdCB7c3Rkb3V0LCBzdGRlcnJ9ID0gYXdhaXQgZXhlYyhweXRob25QYXRoLCBbJy1WJ10pO1xuICAgIGxldCB2ZXJzaW9uU3RyaW5nID0gYCR7c3Rkb3V0fSAke3N0ZGVycn1gLm1hdGNoKC9QeXRob24gKFxcZChcXC5cXGQrKSopL2cpO1xuICAgIGlmICh2ZXJzaW9uU3RyaW5nKSB7XG4gICAgICB2ZXJzaW9uU3RyaW5nID0gdmVyc2lvblN0cmluZy5wb3AoKS5yZXBsYWNlKCdQeXRob24gJywgJycpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvblN0cmluZywgMTApO1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBub2tPcHRpb25hbChgVW5hYmxlIHRvIGlkZW50aWZ5IFB5dGhvbiB2ZXJzaW9uIGNvcnJlY3RseSAodmVyc2lvbiA9ICcke3ZlcnNpb25TdHJpbmd9JykgYXQgJHtweXRob25QYXRofS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIFB5dGhvbiBlbnZpcm9ubWVudCBpbiBQQVRIOiAke3Byb2Nlc3MuZW52LlBBVEh9LiBub2RlLWd5cCAodXNlZCBieSBoZWFwZHVtcCkgcmVxdWlyZXMgUHl0aG9uIDIueGApO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvbiA9PT0gMiA/IG9rT3B0aW9uYWwoYFB5dGhvbiByZXF1aXJlZCBieSBub2RlLWd5cCAodXNlZCBieSBoZWFwZHVtcCkgaXMgaW5zdGFsbGVkIGF0OiAke3B5dGhvblBhdGh9LiBJbnN0YWxsZWQgdmVyc2lvbiBpczogJHt2ZXJzaW9uU3RyaW5nfWApIDpcbiAgICAgIG5va09wdGlvbmFsKCdQeXRob24gdmVyc2lvbiByZXF1aXJlZCBieSBub2RlLWd5cCAodXNlZCBieSBoZWFwZHVtcCkgc2hvdWxkIGJlIDIueCcpO1xuICB9XG5cbiAgZml4ICgpIHtcbiAgICByZXR1cm4gYE1hbnVhbGx5IGNvbmZpZ3VyZSBQeXRob24gMi54IGVudmlyb25tZW50LiBub2RlLWd5cCB3aGljaCBpcyBOb2RlSlMgdG9vbGNoYWluIHJlcXVpcmVzIFB5dGhvbiAyLnhgO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgT3B0aW9uYWxQeXRob25WZXJzaW9uQ2hlY2soKSk7XG5cblxuY2xhc3MgT3B0aW9uYWxPcGVuY3Y0bm9kZWpzQ29tbWFuZENoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgbGV0IHN0ZG91dCA9ICcnO1xuICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gJ29wZW5jdjRub2RlanMnO1xuXG4gICAgY29uc3QgbnBtUGF0aCA9IGF3YWl0IHJlc29sdmVFeGVjdXRhYmxlUGF0aChgbnBtJHtzeXN0ZW0uaXNXaW5kb3dzKCkgPyBgLmNtZGAgOiAnJ31gKTtcbiAgICBpZiAoIW5wbVBhdGgpIHtcbiAgICAgIHJldHVybiBub2tPcHRpb25hbChgJ25wbScgYmluYXJ5IG5vdCBmb3VuZCBpbiBQQVRIOiAke3Byb2Nlc3MuZW52LlBBVEh9YCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICh7c3Rkb3V0fSA9IGF3YWl0IGV4ZWMobnBtUGF0aCwgWydsaXN0JywgJy1nJywgcGFja2FnZU5hbWVdKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cuZGVidWcoZXJyKTtcbiAgICB9XG4gICAgaWYgKHN0ZG91dC5pbmNsdWRlcyhwYWNrYWdlTmFtZSkpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gc3Rkb3V0LnNwbGl0KEVPTCk7XG4gICAgICBjb25zdCBvcGVudmNMaWIgPSBsaW5lcy5maW5kKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiBsaW5lLmluY2x1ZGVzKGAke3BhY2thZ2VOYW1lfUBgKTsgfSk7XG4gICAgICByZXR1cm4gKG9wZW52Y0xpYilcbiAgICAgICAgPyBva09wdGlvbmFsKGAke3BhY2thZ2VOYW1lfSBpcyBpbnN0YWxsZWQgYXQ6ICR7bGluZXNbMF19LiBJbnN0YWxsZWQgdmVyc2lvbiBpczogJHtvcGVudmNMaWIubWF0Y2goLyhcXGQoXFwuXFxkKykqKS9nKS5wb3AoKX1gKVxuICAgICAgICA6IG9rT3B0aW9uYWwoYCR7cGFja2FnZU5hbWV9IGlzIHByb2JhYmx5IGluc3RhbGxlZCBhdDogJHtsaW5lc1swXX0uYCk7XG4gICAgfVxuICAgIHJldHVybiBub2tPcHRpb25hbChgJHtwYWNrYWdlTmFtZX0gY2Fubm90IGJlIGZvdW5kLmApO1xuICB9XG5cbiAgYXN5bmMgZml4ICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgcmV0dXJuICdXaHkgb3BlbmN2NG5vZGVqcyBpcyBuZWVkZWQgYW5kIGhvdyB0byBpbnN0YWxsIGl0OiBodHRwczovL2dpdGh1Yi5jb20vYXBwaXVtL2FwcGl1bS9ibG9iL21hc3Rlci9kb2NzL2VuL3dyaXRpbmctcnVubmluZy1hcHBpdW0vaW1hZ2UtY29tcGFyaXNvbi5tZCc7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBPcHRpb25hbE9wZW5jdjRub2RlanNDb21tYW5kQ2hlY2soKSk7XG5cbmNsYXNzIE9wdGlvbmFsRmZtcGVnQ29tbWFuZENoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgY29uc3QgZmZtcGVnUGF0aCA9IGF3YWl0IHJlc29sdmVFeGVjdXRhYmxlUGF0aCgnZmZtcGVnJyk7XG4gICAgcmV0dXJuIGZmbXBlZ1BhdGhcbiAgICAgID8gb2tPcHRpb25hbChgZmZtcGVnIGlzIGluc3RhbGxlZCBhdDogJHtmZm1wZWdQYXRofS4gJHsoYXdhaXQgZXhlYygnZmZtcGVnJywgWyctdmVyc2lvbiddKSkuc3Rkb3V0LnNwbGl0KEVPTClbMF19YClcbiAgICAgIDogbm9rT3B0aW9uYWwoJ2ZmbXBlZyBjYW5ub3QgYmUgZm91bmQnKTtcbiAgfVxuXG4gIGFzeW5jIGZpeCAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIHJldHVybiAnZmZtcGVnIGlzIG5lZWRlZCB0byByZWNvcmQgc2NyZWVuIGZlYXR1cmVzLiBQbGVhc2UgcmVhZCBodHRwczovL3d3dy5mZm1wZWcub3JnLyB0byBpbnN0YWxsIGl0JztcbiAgfVxufVxuY2hlY2tzLnB1c2gobmV3IE9wdGlvbmFsRmZtcGVnQ29tbWFuZENoZWNrKCkpO1xuXG5leHBvcnQgeyBOb2RlQmluYXJ5Q2hlY2ssIE5vZGVWZXJzaW9uQ2hlY2ssIE9wdGlvbmFsUHl0aG9uVmVyc2lvbkNoZWNrLFxuICBPcHRpb25hbE9wZW5jdjRub2RlanNDb21tYW5kQ2hlY2ssIE9wdGlvbmFsRmZtcGVnQ29tbWFuZENoZWNrIH07XG5leHBvcnQgZGVmYXVsdCBjaGVja3M7XG4iXSwiZmlsZSI6ImxpYi9nZW5lcmFsLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
